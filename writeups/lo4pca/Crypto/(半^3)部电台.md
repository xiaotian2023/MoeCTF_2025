# (åŠ^3)éƒ¨ç”µå°

åšä¸ª200åˆ†çš„é¢˜æŠŠè‡ªå·±SANå€¼ç”¨å…‰äº†â€¦â€¦

æè¿°æåˆ°äº†å¯†ç æœºï¼Œäºæ˜¯è¯·å‡ºchatgptåˆ†æè¿™é¢˜æ˜¯å¦å’ŒæŸä¸ªå·²çŸ¥å¯†ç ç³»ç»Ÿæœ‰å…³ç³»ã€‚å®ƒè¯´è¿™æ˜¯2è½®çš„desã€‚å®Œå…¨ä¸çŸ¥é“deså†…éƒ¨æ˜¯ä»€ä¹ˆç»“æ„çš„æˆ‘é‚æœç´¢ç›¸å…³å†…å®¹ï¼Œå¾—åˆ° https://crypto.stackexchange.com/questions/14567/exercise-attack-on-a-two-round-des-cipher

è¿™ä¸ªèµ„æ–™æè¿°çš„æƒ…å†µä¸è¿™é“é¢˜æœ‰ä¸€ç‚¹ä¸åŒï¼šè¿™é¢˜çš„Få‡½æ•°ä¸æ˜¯é»‘ç›’çš„ï¼Œæ‰€ä»¥å¯ä»¥æ ¹æ®Få‡½æ•°å†…éƒ¨çš„çŠ¶æ€åŠ é€Ÿçˆ†ç ´keyã€‚èµ„æ–™å†…çš„è¿™ä¸ªç»“è®ºéå¸¸é‡è¦ï¼š
```
ğ¿1=ğ‘…0
ğ‘…1=ğ¿0âŠ•ğ¹(ğ‘…0,ğ¾0)

ğ¿2=ğ‘…1=ğ¿0âŠ•ğ¹(ğ‘…0,ğ¾0)
ğ‘…2=ğ¿1âŠ•ğ¹(ğ‘…1,ğ¾1)=ğ¿1âŠ•ğ¹(ğ¿0âŠ•ğ¹(ğ‘…0,ğ¾0),ğ¾1)
```
åˆ©ç”¨é¢˜ç›®ç»™å‡ºçš„ä¸€ä¸ªæ˜æ–‡-å¯†æ–‡å¯¹ï¼Œæˆ‘ä»¬èƒ½å¾—åˆ°ğ¹(ğ‘…0,ğ¾0)å’Œğ¹(ğ‘…1,ğ¾1)çš„å€¼ï¼š
```
ğ¹(ğ‘…0,ğ¾0)=ğ¿2âŠ•ğ¿0
ğ¹(ğ‘…1,ğ¾1)=ğ‘…2âŠ•ğ‘…0
```
è¿™é¢˜çš„Få‡½æ•°æ˜¯ä»`R_expanded = `åˆ°`res_p = `çš„éƒ¨åˆ†ã€‚æ¥ä¸‹æ¥åˆ†ææ€ä¹ˆåˆ©ç”¨Få‡½æ•°å¾—åˆ°subkey

- Få‡½æ•°çš„è¾“å‡ºæ˜¯res_pï¼Œä¸ºresåº”ç”¨Pæ’åˆ—åçš„ç»“æœ->å¯¹res_pé€†åº”ç”¨På¾—åˆ°åŸæœ¬çš„res
- resä¸ºä¸€ä¸ª32 bitå­—ç¬¦ä¸²ï¼Œæ¯4ä¸ªbitä¸ºint_res->æŒ‰4ä¸ªbitä¸ºä¸€ç»„åˆ†å‰²resï¼Œå¾—åˆ°int_res
- `int_res = self.S[i][16 * row + col]`->`16 * row + col=self.S[i].index(int_res)`
- ç°åœ¨é—®é¢˜æ¥äº†ã€‚æŸ¥çœ‹æ¯ä¸ªSç›’çš„æ„é€ ï¼Œå‘ç°ç›’é‡Œçš„64ä¸ªå€¼å®é™…ä¸Šæ˜¯16ä¸ªæ‰“ä¹±çš„å€¼é‡å¤4è¡Œï¼Œæ„å‘³ç€`16 * row + col`çš„å€¼ä¸å”¯ä¸€ã€‚å› æ­¤éœ€è¦çˆ†ç ´rowå€¼çš„å››ç§å¯èƒ½ï¼Œç®—å‡ºå¯¹åº”çš„colå€¼
- ç”¨rowå’Œcolå€¼èƒ½å¤Ÿæ¢å¤`R_groups[i]`çš„å€¼
- `R_groups`å¼‚æˆ–`R_expanded`å¯ä»¥å¾—åˆ° $k_i$

ä¸Šè¿°è¿‡ç¨‹åªéœ€è¦ä¸€å—æ˜æ–‡-å¯†æ–‡ï¼ˆ64bitï¼‰å°±èƒ½å®ç°ï¼Œå¾—åˆ°æ‰€æœ‰å¯èƒ½çš„ $k_0,k_1$ å€¼ã€‚ç„¶åå¯ä»¥ç”¨æ˜æ–‡-å¯†æ–‡å¯¹å‰©ä¸‹çš„éƒ¨åˆ†ç­›é€‰å‡ºçœŸæ­£çš„ $k_0,k_1$

çœ‹åˆ°è¿™å…¶å®å°±å¯ä»¥äº†ã€‚å› ä¸ºæˆ‘ä¸ä¼šå¤„ç†ç»†èŠ‚ï¼ˆè€Œä¸”ç»†èŠ‚ä¹Ÿä¸é‡è¦ï¼Œç¦»å¼€è¿™é¢˜å°±æ²¡ç”¨äº†ï¼‰ï¼Œè€Œä¸”æˆ‘æ°¸è¿œåˆ†ä¸æ¸…ç±»feistelç½‘ç»œçš„Lå’ŒRï¼Œå†åŠ ä¸Šæˆ‘çš„pythonæ°´å¹³ä»æœªæå‡ï¼Œæœ€åæˆ‘å†™åˆ°åé¢å·²ç»ç¥å¿—ä¸æ¸…äº†ï¼›å¯¼è‡´æœ€åçš„è„šæœ¬ä¹±ä¸ƒå…«ç³Ÿçš„ï¼ŒåŸºæœ¬æ²¡æœ‰ä»»ä½•é˜…è¯»çš„æ„ä¹‰
```py
from Crypto.Util.number import *
from itertools import product
#çœç•¥8ä¸ªSç›’ï¼ŒIPï¼ŒPå’ŒEè¡¨
S = [S1, S2, S3, S4, S5, S6, S7, S8]
P_inv=[P.index(i) + 1 for i in range(1, 33)]
IP_inv = [IP.index(i) + 1 for i in range(1, 65)]
def xor(a,b):
    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))
def apply(a,table):
    return ''.join(a[i - 1] for i in table)
def inv_IP(a):
    return ''.join(a[i - 1] for i in IP_inv)
def inv_P(a):
    return ''.join(a[i - 1] for i in P_inv)
def to_bin(text):
    bin_text = ''.join([bin(byte)[2:].zfill(8) for byte in text])
    padded_len = (64 - (len(bin_text) % 64)) % 64
    return bin_text + '0' * padded_len
def split(bin_text):
    return [bin_text[i * 64:(i + 1) * 64] for i in range(0, len(bin_text) // 64)]
flag=
m=
c=
c=long_to_bytes(c)
m=long_to_bytes(m)
flag=long_to_bytes(flag)
splitted_m=split(to_bin(m))
splitted_flag=split(to_bin(flag))
split_c=split(to_bin(c))
possible_keys=[[] for _ in range(2)]
def brute(res,R_expanded,idx):
    R_groups=[[] for _ in range(8)]
    for j in range(8):
        int_res=int(res[j*4:j*4+4],2)
        for row in range(4):
            col=bin(S[j][16*row:16*row+16].index(int_res))[2:].zfill(4)
            row=bin(row)[2:].zfill(2)
            R_groups[j].append(row[0]+col+row[1])
    for comb in product(*R_groups):
        possible_keys[idx].append(xor(''.join(comb),R_expanded))
block=split_c[0]
m_block=apply(splitted_m[0],IP)
init_L, init_R = m_block[:32], m_block[32:]
c_block = apply(block,IP)
L2, R2 = c_block[32:], c_block[:32] #å› ä¸ºæœ€åå¾—åˆ°çš„t = R + L
brute(inv_P(xor(L2, init_L)),apply(init_R,E),0)
brute(inv_P(xor(R2, init_R)),apply(L2,E),1)
def F(R,k):
    R_expanded = ''.join(R[i - 1] for i in E)
    R_xor = [str(int(R_expanded[i]) ^ int(k[i])) for i in range(48)]
    R_groups = [R_xor[i:i + 6] for i in range(0, 48, 6)]
    res = ''
    for i in range(8):
        row = int(R_groups[i][0] + R_groups[i][5], base=2)
        col = int(''.join(R_groups[i][1:5]), base=2)
        int_res = S[i][16 * row + col]
        res += bin(int_res)[2:].zfill(4)
    return ''.join(res[i - 1] for i in P)
def brute_k1(possible_keys,L2,R2,expected_R0):
    keys=set()
    for k1 in possible_keys:
        res=xor(R2,F(L2,k1))
        if res==expected_R0 and k1 not in keys:
            keys.add(k1)
    return keys
def brute_k0(possible_keys,L2,expected_R0,expected_L0):
    keys=set()
    for k0 in possible_keys:
        res=xor(L2,F(expected_R0,k0))
        if res==expected_L0 and k0 not in keys:
            keys.add(k0)
    return keys
print("Finish gathering possible keys")
print("Finding k1 now")
keys=set(possible_keys[1])
for i in range(1,len(splitted_m)):
    test_block=apply(split_c[i],IP)
    L2,R2=test_block[32:], test_block[:32]
    candidates=brute_k1(keys,L2,R2,apply(splitted_m[i],IP)[32:])
    if len(candidates)==0:
        continue
    keys&=candidates
    if len(keys)==1:
        break
k1=keys.pop()
print(f"{k1=}")
print("Finding k0 now")
keys=set(possible_keys[0])
for i in range(1,len(splitted_m)):
    test_block=apply(split_c[i],IP)
    L2=test_block[32:]
    candidates=brute_k0(keys,L2,apply(splitted_m[i],IP)[32:],apply(splitted_m[i],IP)[:32])
    if len(candidates)==0:
        continue
    keys&=candidates
    if len(keys)==1:
        break
k0=keys.pop()
print(f"{k0=}")
def decrypt(k0,k1,block):
    block=apply(block,IP)
    L2, R2 = block[32:], block[:32]
    R0=xor(R2,F(L2,k1))
    L0=xor(L2,F(R0,k0))
    return inv_IP(L0+R0)
flag=''
for i in range(len(splitted_flag)):
    flag+=decrypt(k0,k1,splitted_flag[i])
message=long_to_bytes(int(flag,2)).decode()
print(message)
flag=''
for i in range(len(message)-1):
    if message[i+1]=='.':
        flag+=message[i]
print(flag)
```
ï¼ˆä½†æ˜¯çœ‹ç€æŒºå£®è§‚çš„ï¼‰